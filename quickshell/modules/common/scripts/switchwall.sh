#!/usr/bin/env bash

XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
CONFIG_DIR="~/.config/desktopia/"
CACHE_DIR="$XDG_CACHE_HOME/desktopia"
STATE_DIR="$XDG_STATE_HOME/desktopia"
SHELL_CONFIG="$HOME/.desktopia/settings.json"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MATUGEN_DIR="$XDG_CONFIG_HOME/matugen"
terminalscheme="$CONFIG_DIR/terminal/scheme-base.json"

handle_kde_material_you_colors() {
    echo "j"
}

# Initialize swww daemon if not running
init_swww() {
    if ! pgrep -x "swww-daemon" > /dev/null; then
        echo "[INFO] Starting swww daemon..."
        swww-daemon &
        sleep 2  # Give daemon time to start
    fi
    
    # Verify swww can query displays
    if ! swww query &>/dev/null; then
        echo "[ERROR] swww daemon not responding. Restarting..."
        pkill swww-daemon 2>/dev/null
        sleep 1
        swww-daemon &
        sleep 3
        
        if ! swww query &>/dev/null; then
            echo "[ERROR] swww daemon failed to start properly"
            return 1
        fi
    fi
    
    echo "[INFO] swww daemon is running"
    return 0
}

pre_process() {
    local mode_flag="$1"
    # Set GNOME color-scheme if mode_flag is dark or light
    if [[ "$mode_flag" == "dark" ]]; then
        gsettings set org.gnome.desktop.interface color-scheme 'prefer-dark'
        gsettings set org.gnome.desktop.interface gtk-theme 'adw-gtk3-dark'
    elif [[ "$mode_flag" == "light" ]]; then
        gsettings set org.gnome.desktop.interface color-scheme 'prefer-light'
        gsettings set org.gnome.desktop.interface gtk-theme 'adw-gtk3'
    fi

    if [ ! -d "$CACHE_DIR"/user/generated ]; then
        mkdir -p "$CACHE_DIR"/user/generated
    fi
}

post_process() {
    local screen_width="$1"
    local screen_height="$2"
    local wallpaper_path="$3"

    handle_kde_material_you_colors &
}

check_and_prompt_upscale() {
    local img="$1"
    min_width_desired="$(hyprctl monitors -j | jq '([.[].width] | max)' | xargs)" # max monitor width
    min_height_desired="$(hyprctl monitors -j | jq '([.[].height] | max)' | xargs)" # max monitor height

    if command -v identify &>/dev/null && [ -f "$img" ]; then
        local img_width img_height
        if is_video "$img"; then # Not check resolution for videos, just let em pass
            img_width=$min_width_desired
            img_height=$min_height_desired
        else
            img_width=$(identify -format "%w" "$img" 2>/dev/null)
            img_height=$(identify -format "%h" "$img" 2>/dev/null)
        fi
        if [[ "$img_width" -lt "$min_width_desired" || "$img_height" -lt "$min_height_desired" ]]; then
            action=$(notify-send "Upscale?" \
                "Image resolution (${img_width}x${img_height}) is lower than screen resolution (${min_width_desired}x${min_height_desired})" \
                -A "open_upscayl=Open Upscayl"\
                -a "Wallpaper switcher")
            if [[ "$action" == "open_upscayl" ]]; then
                if command -v upscayl &>/dev/null; then
                    nohup upscayl > /dev/null 2>&1 &
                else
                    action2=$(notify-send \
                        -a "Wallpaper switcher" \
                        -c "im.error" \
                        -A "install_upscayl=Install Upscayl (Arch)" \
                        "Install Upscayl?" \
                        "yay -S upscayl-bin")
                    if [[ "$action2" == "install_upscayl" ]]; then
                        foot epsi i upscayl-bin
                        if command -v upscayl &>/dev/null; then
                            nohup upscayl > /dev/null 2>&1 &
                        fi
                    fi
                fi
            fi
        fi
    fi
}

THUMBNAIL_DIR="/tmp/mpvpaper_thumbnails"
CUSTOM_DIR="$XDG_CONFIG_HOME/hypr/custom"
RESTORE_SCRIPT_DIR="$CUSTOM_DIR/scripts"
RESTORE_SCRIPT="$RESTORE_SCRIPT_DIR/__restore_video_wallpaper.sh"
VIDEO_OPTS="no-audio loop hwdec=auto scale=bilinear interpolation=no video-sync=display-resample panscan=1.0 video-scale-x=1.0 video-scale-y=1.0 video-align-x=0.5 video-align-y=0.5"

is_video() {
    local extension="${1##*.}"
    [[ "$extension" == "mp4" || "$extension" == "mkv" || "$extension" == "webm" ]] && return 0 || return 1
}

kill_existing_mpvpaper() {
    pkill -f -9 mpvpaper || true
}

create_restore_script() {
    local video_path=$1
    mkdir -p "$RESTORE_SCRIPT_DIR"
    cat > "$RESTORE_SCRIPT.tmp" << EOF
#!/bin/bash
# Generated by switchwall.sh - Don't modify it by yourself.
# Time: $(date)

pkill -f -9 mpvpaper

for monitor in \$(hyprctl monitors -j | jq -r '.[] | .name'); do
    mpvpaper -o "$VIDEO_OPTS" "\$monitor" "$video_path" --mpv-options '--load-scripts=no' &
    sleep 0.1
done
EOF
    mv "$RESTORE_SCRIPT.tmp" "$RESTORE_SCRIPT"
    chmod +x "$RESTORE_SCRIPT"
}

remove_restore() {
    mkdir -p "$RESTORE_SCRIPT_DIR"
    cat > "$RESTORE_SCRIPT.tmp" << EOF
#!/bin/bash
# The content of this script will be generated by switchwall.sh - Don't modify it by yourself.
EOF
    mv "$RESTORE_SCRIPT.tmp" "$RESTORE_SCRIPT"
}

# Set wallpaper using swww with error handling
set_wallpaper_swww() {
    local imgpath="$1"
    
    echo "[INFO] Setting wallpaper: $imgpath"
    
    # Verify image exists and is readable
    if [[ ! -f "$imgpath" ]]; then
        echo "[ERROR] Image file does not exist: $imgpath"
        return 1
    fi
    
    if [[ ! -r "$imgpath" ]]; then
        echo "[ERROR] Image file is not readable: $imgpath"
        return 1
    fi
    
    # Initialize swww daemon
    if ! init_swww; then
        echo "[ERROR] Failed to initialize swww daemon"
        return 1
    fi
    
    # Set wallpaper with error handling
    local swww_output
    if swww_output=$(swww img "$imgpath" \
        --transition-type grow \
        --transition-step 90 \
        --transition-fps 144 \
        --transition-duration 1.5 \
        --transition-angle 0 \
        --transition-bezier 0.54,0,0.34,0.99 2>&1); then
        echo "[INFO] Wallpaper set successfully"
        
        # Update config file
        if [ -f "$SHELL_CONFIG" ]; then
            if jq --arg path "$imgpath" '.background.wallpaperPath = $path' "$SHELL_CONFIG" > "$SHELL_CONFIG.tmp"; then
                mv "$SHELL_CONFIG.tmp" "$SHELL_CONFIG"
                echo "[INFO] Updated config file"
            else
                echo "[WARN] Failed to update config file"
                rm -f "$SHELL_CONFIG.tmp"
            fi
        else
            echo "[WARN] Config file not found: $SHELL_CONFIG"
        fi
        
        return 0
    else
        echo "[ERROR] swww failed to set wallpaper:"
        echo "$swww_output"
        return 1
    fi
}

switch() {
    imgpath="$1"
    mode_flag="$2"
    type_flag="$3"
    color_flag="$4"
    color="$5"
    read scale screenx screeny screensizey < <(hyprctl monitors -j | jq '.[] | select(.focused) | .scale, .x, .y, .height' | xargs)
    cursorposx=$(hyprctl cursorpos -j | jq '.x' 2>/dev/null) || cursorposx=960
    cursorposx=$(bc <<< "scale=0; ($cursorposx - $screenx) * $scale / 1")
    cursorposy=$(hyprctl cursorpos -j | jq '.y' 2>/dev/null) || cursorposy=540
    cursorposy=$(bc <<< "scale=0; ($cursorposy - $screeny) * $scale / 1")
    cursorposy_inverted=$((screensizey - cursorposy))

    if [[ "$color_flag" == "1" ]]; then
        matugen_args=(color hex "$color")
        generate_colors_material_args=(--color "$color")
    else
        if [[ -z "$imgpath" ]]; then
            echo 'Aborted'
            exit 0
        fi

        check_and_prompt_upscale "$imgpath" &
        kill_existing_mpvpaper

        if is_video "$imgpath"; then
            mkdir -p "$THUMBNAIL_DIR"

            missing_deps=()
            if ! command -v mpvpaper &> /dev/null; then
                missing_deps+=("mpvpaper")
            fi
            if ! command -v ffmpeg &> /dev/null; then
                missing_deps+=("ffmpeg")
            fi
            if [ ${#missing_deps[@]} -gt 0 ]; then
                echo "Missing deps: ${missing_deps[*]}"
                echo "Arch: sudo pacman -S ${missing_deps[*]}"
                action=$(notify-send \
                    -a "Wallpaper switcher" \
                    -c "im.error" \
                    -A "install_arch=Install (Arch)" \
                    "Can't switch to video wallpaper" \
                    "Missing dependencies: ${missing_deps[*]}")
                if [[ "$action" == "install_arch" ]]; then
                    kitty -1 sudo pacman -S "${missing_deps[*]}"
                    if command -v mpvpaper &>/dev/null && command -v ffmpeg &>/dev/null; then
                        notify-send 'Wallpaper switcher' 'Alright, try again!' -a "Wallpaper switcher"
                    fi
                fi
                exit 0
            fi

            local video_path="$imgpath"
            monitors=$(hyprctl monitors -j | jq -r '.[] | .name')
            for monitor in $monitors; do
                mpvpaper -o "$VIDEO_OPTS" "$monitor" "$video_path" --mpv-options '--load-scripts=no' &
                sleep 0.1
            done

            # Extract first frame for color generation
            thumbnail="$THUMBNAIL_DIR/$(basename "$imgpath").jpg"
            ffmpeg -y -i "$imgpath" -vframes 1 "$thumbnail" 2>/dev/null

            if [ -f "$thumbnail" ]; then
                matugen_args=(image "$thumbnail")
                generate_colors_material_args=(--path "$thumbnail")
                create_restore_script "$video_path"
            else
                echo "Cannot create image to colorgen"
                remove_restore
                exit 1
            fi
        else
            # Handle static images
            matugen_args=(image "$imgpath")
            generate_colors_material_args=(--path "$imgpath")

            # Set wallpaper using improved swww function
            if ! set_wallpaper_swww "$imgpath"; then
                echo "[ERROR] Failed to set wallpaper with swww"
                # Try fallback methods if available
                if command -v hyprctl &>/dev/null; then
                    echo "[INFO] Trying hyprpaper fallback..."
                    hyprctl hyprpaper wallpaper ",$imgpath" 2>/dev/null || echo "[WARN] hyprpaper fallback failed"
                fi
                exit 1
            fi
            
            remove_restore
        fi
    fi

    # Determine mode if not set
    if [[ -z "$mode_flag" ]]; then
        current_mode=$(gsettings get org.gnome.desktop.interface color-scheme 2>/dev/null | tr -d "'")
        if [[ "$current_mode" == "prefer-dark" ]]; then
            mode_flag="dark"
        else
            mode_flag="light"
        fi
    fi

    [[ -n "$mode_flag" ]] && matugen_args+=(--mode "$mode_flag") && generate_colors_material_args+=(--mode "$mode_flag")
    [[ -n "$type_flag" ]] && matugen_args+=(--type "$type_flag") && generate_colors_material_args+=(--scheme "$type_flag")
    generate_colors_material_args+=(--termscheme "$terminalscheme" --blend_bg_fg)
    generate_colors_material_args+=(--cache "$STATE_DIR/user/generated/color.txt")

    pre_process "$mode_flag"

    if command -v matugen &>/dev/null; then
        matugen "${matugen_args[@]}"
    else
        echo "[WARN] matugen not found, skipping color generation"
    fi
    
    if [[ -f "$SCRIPT_DIR/generate_colors_material.py" ]]; then
        python3 "$SCRIPT_DIR/generate_colors_material.py" "${generate_colors_material_args[@]}" \
            > "$STATE_DIR"/user/generated/material_colors.scss
    else
        echo "[WARN] generate_colors_material.py not found"
    fi
    
    if [[ -f "$SCRIPT_DIR/applycolor.sh" ]]; then
        "$SCRIPT_DIR"/applycolor.sh
    else
        echo "[WARN] applycolor.sh not found"
    fi

    # Pass screen width, height, and wallpaper path to post_process
    max_width_desired="$(hyprctl monitors -j | jq '([.[].width] | min)' | xargs)"
    max_height_desired="$(hyprctl monitors -j | jq '([.[].height] | min)' | xargs)"
    post_process "$max_width_desired" "$max_height_desired" "$imgpath"
}

main() {
    imgpath=""
    mode_flag=""
    type_flag=""
    color_flag=""
    color=""
    noswitch_flag=""

    # Check if swww is installed
    if ! command -v swww &>/dev/null; then
        echo "[ERROR] swww is not installed. Please install it first:"
        echo "Arch: sudo pacman -S swww"
        echo "Or build from source: https://github.com/Horus645/swww"
        exit 1
    fi

    get_type_from_config() {
        jq -r '.appearance.palette.type' "$SHELL_CONFIG" 2>/dev/null || echo "auto"
    }

    detect_scheme_type_from_image() {
        local img="$1"
        if [[ -f "$SCRIPT_DIR/scheme_for_image.py" ]]; then
            "$SCRIPT_DIR"/scheme_for_image.py "$img" 2>/dev/null | tr -d '\n'
        else
            echo "scheme-tonal-spot"  # fallback
        fi
    }

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --mode)
                mode_flag="$2"
                shift 2
                ;;
            --type)
                type_flag="$2"
                shift 2
                ;;
            --color)
                color_flag="1"
                if [[ "$2" =~ ^#?[A-Fa-f0-9]{6}$ ]]; then
                    color="$2"
                    shift 2
                else
                    if command -v hyprpicker &>/dev/null; then
                        color=$(hyprpicker --no-fancy)
                    else
                        echo "[ERROR] hyprpicker not found and no valid color provided"
                        exit 1
                    fi
                    shift
                fi
                ;;
            --image)
                imgpath="$2"
                shift 2
                ;;
            --noswitch)
                noswitch_flag="1"
                imgpath=$(jq -r '.background.wallpaperPath' "$SHELL_CONFIG" 2>/dev/null || echo "")
                shift
                ;;
            *)
                if [[ -z "$imgpath" ]]; then
                    imgpath="$1"
                fi
                shift
                ;;
        esac
    done

    # If type_flag is not set, get it from config
    if [[ -z "$type_flag" ]]; then
        type_flag="$(get_type_from_config)"
    fi

    # Validate type_flag (allow 'auto' as well)
    allowed_types=(scheme-content scheme-expressive scheme-fidelity scheme-fruit-salad scheme-monochrome scheme-neutral scheme-rainbow scheme-tonal-spot auto)
    valid_type=0
    for t in "${allowed_types[@]}"; do
        if [[ "$type_flag" == "$t" ]]; then
            valid_type=1
            break
        fi
    done
    if [[ $valid_type -eq 0 ]]; then
        echo "[switchwall.sh] Warning: Invalid type '$type_flag', defaulting to 'auto'" >&2
        type_flag="auto"
    fi

    # Only prompt for wallpaper if not using --color and not using --noswitch and no imgpath set
    if [[ -z "$imgpath" && -z "$color_flag" && -z "$noswitch_flag" ]]; then
        # Try multiple possible wallpaper directories
        wallpaper_dir=""
        for dir in "$HOME/.sleex/wallpapers" "$(xdg-user-dir PICTURES 2>/dev/null)" "$HOME/Pictures" "$HOME"; do
            if [[ -d "$dir" ]]; then
                wallpaper_dir="$dir"
                break
            fi
        done
        
        if [[ -z "$wallpaper_dir" ]]; then
            echo "[ERROR] No suitable directory found for wallpaper selection"
            exit 1
        fi
        
        cd "$wallpaper_dir"
        
        if command -v kdialog &>/dev/null; then
            imgpath="$(kdialog --getopenfilename . --title 'Choose wallpaper')"
        elif command -v zenity &>/dev/null; then
            imgpath="$(zenity --file-selection --title='Choose wallpaper')"
        else
            echo "[ERROR] No file picker available (kdialog or zenity required)"
            exit 1
        fi
    fi

    # If type_flag is 'auto', detect scheme type from image (after imgpath is set)
    if [[ "$type_flag" == "auto" ]]; then
        if [[ -n "$imgpath" && -f "$imgpath" ]]; then
            detected_type="$(detect_scheme_type_from_image "$imgpath")"
            # Only use detected_type if it's valid
            valid_detected=0
            for t in "${allowed_types[@]}"; do
                if [[ "$detected_type" == "$t" && "$detected_type" != "auto" ]]; then
                    valid_detected=1
                    break
                fi
            done
            if [[ $valid_detected -eq 1 ]]; then
                type_flag="$detected_type"
            else
                echo "[switchwall] Warning: Could not auto-detect a valid scheme, defaulting to 'scheme-tonal-spot'" >&2
                type_flag="scheme-tonal-spot"
            fi
        else
            echo "[switchwall] Warning: No image to auto-detect scheme from, defaulting to 'scheme-tonal-spot'" >&2
            type_flag="scheme-tonal-spot"
        fi
    fi

    if [[ "$color_flag" != "1" && -z "$noswitch_flag" ]]; then
        if [[ -z "$imgpath" || ! -f "$imgpath" ]]; then
            echo "[WARN] No valid image path detected — selecting..."
            
            # Try to find a suitable directory and file picker
            wallpaper_dir="$HOME/.sleex/wallpapers"
            if [[ ! -d "$wallpaper_dir" ]]; then
                wallpaper_dir=$(xdg-user-dir PICTURES 2>/dev/null || echo "$HOME/Pictures")
            fi
            if [[ ! -d "$wallpaper_dir" ]]; then
                wallpaper_dir="$HOME"
            fi
            
            if command -v kdialog &>/dev/null; then
                imgpath="$(kdialog --getopenfilename "$wallpaper_dir" --title 'Choose wallpaper')"
            elif command -v zenity &>/dev/null; then
                imgpath="$(zenity --file-selection --title='Choose wallpaper' --filename="$wallpaper_dir/")"
            else
                echo "[ERROR] No file picker available (kdialog or zenity required)"
                exit 1
            fi
            
            # Final check
            if [[ -z "$imgpath" || ! -f "$imgpath" ]]; then
                echo "[ERROR] No valid wallpaper selected. Aborting."
                exit 1
            fi
        fi
    fi

    switch "$imgpath" "$mode_flag" "$type_flag" "$color_flag" "$color"
}

main "$@"